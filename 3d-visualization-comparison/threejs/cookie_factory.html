<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cookie Factory Digital Twin - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
        .property {
            margin: 5px 0;
        }
        .value {
            font-weight: bold;
            color: #4CAF50;
        }
        .alarm {
            color: #FF5252;
        }
        .normal {
            color: #4CAF50;
        }
        .acknowledged {
            color: #FFC107;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h2>Cookie Factory Mixer</h2>
            <div class="property">
                Temperature: <span id="temperature" class="value">100</span>Â°C
            </div>
            <div class="property">
                RPM: <span id="rpm" class="value">60</span>
            </div>
            <div class="property">
                Status: <span id="status" class="value normal">NORMAL</span>
            </div>
            <p>
                <small>Connected to Eclipse Ditto via HTTP API - Live updates every 2 seconds</small>
            </p>
        </div>
        <div id="loading">Loading 3D model...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Scene setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xcccccc,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Mixer model and state
        let mixer;
        let mixerModel;
        let rotatingPart;
        const mixerState = {
            temperature: 100,
            rpm: 60,
            status: 'NORMAL'
        };

        // Load the model
        const loader = new THREE.GLTFLoader();
        loader.load('models/CookieFactoryMixer.glb', (gltf) => {
            mixerModel = gltf.scene;
            
            // Apply shadows to all meshes
            mixerModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
                
                // Identify the rotating part by name (you may need to adjust this)
                if (node.isMesh && node.name.toLowerCase().includes('mixer') || 
                    node.name.toLowerCase().includes('blade')) {
                    rotatingPart = node;
                    console.log("Found rotating part:", node.name);
                }
            });
            
            // Position the model
            mixerModel.position.y = 0;
            mixerModel.scale.set(1, 1, 1);
            
            scene.add(mixerModel);
            document.getElementById('loading').style.display = 'none';
            
            // If we couldn't find the rotating part, use the whole model
            if (!rotatingPart) {
                console.log("No specific rotating part found, using first mesh");
                mixerModel.traverse((node) => {
                    if (!rotatingPart && node.isMesh) {
                        rotatingPart = node;
                    }
                });
            }
        }, 
        // Progress callback
        (xhr) => {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
            document.getElementById('loading').textContent = `Loading 3D model... ${percent}%`;
        },
        // Error callback
        (error) => {
            console.error('Error loading model:', error);
            document.getElementById('loading').textContent = 'Error loading 3D model!';
        });

        // Add polling function to get updates from the HTTP API
        function pollDittoState() {
            const thingId = "org.eclipse.ditto:Mixer";
            const apiUrl = `http://localhost:8080/api/2/things/${thingId}`;
            
            // Basic auth credentials 
            const headers = new Headers();
            headers.set('Authorization', 'Basic ' + btoa('ditto:ditto'));
            
            fetch(apiUrl, { 
                method: 'GET',
                headers: headers
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Fetched thing data from HTTP API:', data);
                
                // Update temperature if available
                if (data.features?.Mixer?.properties?.Temperature !== undefined) {
                    const temp = parseFloat(data.features.Mixer.properties.Temperature);
                    if (!isNaN(temp)) {
                        mixerState.temperature = temp;
                        document.getElementById('temperature').textContent = temp.toFixed(1);
                    }
                }
                
                // Update RPM if available
                if (data.features?.Mixer?.properties?.RPM !== undefined) {
                    const rpm = parseFloat(data.features.Mixer.properties.RPM);
                    if (!isNaN(rpm)) {
                        mixerState.rpm = rpm;
                        document.getElementById('rpm').textContent = rpm.toFixed(1);
                    }
                }
                
                // Update status if available
                if (data.features?.Alarm?.properties?.alarm_status !== undefined) {
                    const status = data.features.Alarm.properties.alarm_status;
                    mixerState.status = status;
                    const statusElement = document.getElementById('status');
                    statusElement.textContent = status;
                    
                    // Update CSS class based on status
                    statusElement.className = 'value';
                    if (status === 'NORMAL') {
                        statusElement.classList.add('normal');
                    } else if (status === 'ACKNOWLEDGED') {
                        statusElement.classList.add('acknowledged');
                    } else if (status === 'ACTIVE') {
                        statusElement.classList.add('alarm');
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching from Ditto API:', error);
            });
        }
        
        // Start polling every 2 seconds
        const pollingInterval = setInterval(pollDittoState, 2000);
        
        // Initial poll
        pollDittoState();

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Calculate delta time in seconds
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            
            // Update controls
            controls.update();
            
            // Rotate the mixer part based on RPM
            if (rotatingPart) {
                // Convert RPM to radians per second
                const radiansPerSecond = (mixerState.rpm / 60) * Math.PI * 2;
                rotatingPart.rotation.y += radiansPerSecond * deltaTime;
            }
            
            renderer.render(scene, camera);
        }
        animate(0);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>